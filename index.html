<head>
  <script src="three.js"></script>
  <script type="module" src="tween.module.min.js"></script>
  <script type="module" src="three.module.js"></script>
  <script type="module" src="Pass.js"></script>
  <script type="module" src="ShaderPass.js"></script>
  <script type="module" src="LuminosityHighPassShader.js"></script>
  <script type="module" src="CopyShader.js"></script>
  <script type="module" src="RenderPass.js"></script>
  <script type="module" src="BloomPass.js"></script>
  <script type="module" src="EffectComposer.js"></script>
  <script type="module" src="UnrealBloomPass.js"></script>
  <script type="module" src="GLTFLoader.js"></script>
  <script type="module" src="FXAAShader.js"></script>
  <style>
    body {
      margin: 0;
    }
    .background{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    .scroll{
      height: 11000px;
    }
  </style>
</head>
<body>
  <div class="background" id="background"></div>
  <div class="scroll" id="scroll"></div>
  
  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec3 vNormal;
    varying vec3 vPositionNormal;
    void main() 
    {
      vNormal = normalize( normalMatrix * normal );
      vPositionNormal = normalize(( modelViewMatrix * vec4(position, 1.0) ).xyz);
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
  </script>
  <script id="fragmentShader" type="x-shader/x-vertex"> 
    uniform vec3 glowColor;
    uniform float b;
    uniform float p;
    uniform float s;
    varying vec3 vNormal;
    varying vec3 vPositionNormal;
    void main() 
    {
      float a = pow( b + s * abs(dot(vNormal, vPositionNormal)), p );
      gl_FragColor = vec4( glowColor, a );
    }
  </script>
  <script type="module">
    const modelurl = "./models/border.glb";
    const modelurl2 = "./models/dots.glb";
    const line6 =  "./models/line6.glb";

    const loadModel = (url) => {
      return new Promise((resolve, reject)=>{
        const manager = new THREE.LoadingManager();
        const loader = new THREE.GLTFLoader(manager);
        loader.load(
          url,
          function (gltf) {
            resolve(gltf.scene);
          },
          function (xhr) {
          },
          function (error) {
            console.log(error);
          }
        );
      });
    }

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if(isMobile){
      document.getElementById('scroll').style.display = 'none';
      //let elem = document.documentElement;
      //if (elem.requestFullscreen) {
      //  elem.requestFullscreen();
      //}
    }

    let shield1StartPosition = null;
    let shield2StartPosition = null;
    let shield3StartPosition = null;
    const sceneMeshes = [];
    let composer, modelDots, shield1,  shield2, shield3, line1, line2, line3, line4, plane1, plane2, plane3;
    let shield1Pivot = new THREE.Object3D();
    let shield2Pivot = new THREE.Object3D();
    let shield3Pivot = new THREE.Object3D();
    let lockShiled1 = isMobile;
    let lockShiled2 = isMobile;
    let lockShiled3 = isMobile;
    let lockLookShieled = false;
    let rotationPivot = true;

    let scene = new THREE.Scene();
    const loader = new THREE.CubeTextureLoader();
    const texture = loader.load([
      'textures/NewSkyboxFace4.jpg', // Left
      'textures/NewSkyboxFace5.jpg', // Right
      'textures/NewSkyboxFace2.jpg', // Top
      'textures/NewSkyboxFace6.jpg', // Bottom
      'textures/NewSkyboxFace1.jpg', // Back
      'textures/NewSkyboxFace3.jpg', // Forward
    ]);
    scene.background = texture;
    //scene.background = new THREE.Color(0.009496, 0.014244, 0.037984, 1);
    let camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
    scene.add( camera );
    let renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( 2.3 );
    if(isMobile) {
      if(window.innerHeight > window.innerWidth)
        renderer.setSize( window.innerHeight, window.innerWidth );
    } else {
      renderer.setSize( window.innerWidth, window.innerHeight );
    }
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = Math.pow( 1.1, 1.1 );
     
    document.getElementById('background').appendChild( renderer.domElement );

    const pointLight = new THREE.PointLight( 0xffffff, 1.7 );
    camera.add( pointLight );
      
    //if(isMobile){
    //  camera.position.z = 40;
     // camera.position.y = 18;
    //} else {
      camera.position.z = 70;
      camera.position.y = 10;
    //}

    let step = 1;
    let pivot = new THREE.Object3D();
    scene.add( pivot );

    const renderScene = new THREE.RenderPass( scene, camera );

    const bloomPass = new  THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
    bloomPass.threshold = 0;
    bloomPass.strength = 1.1;
    bloomPass.radius = 0;

    composer = new THREE.EffectComposer( renderer );
    composer.addPass( renderScene );
    composer.addPass( bloomPass );

    const effectFXAA = new THREE.ShaderPass( THREE.FXAAShader );
    effectFXAA.uniforms[ 'resolution' ].value.x = 1 / ( window.innerWidth * renderer.getPixelRatio() );
    effectFXAA.uniforms[ 'resolution' ].value.y = 1 / ( window.innerHeight * renderer.getPixelRatio() );
    composer.addPass( effectFXAA ); 


    let material = new THREE.MeshStandardMaterial( { color: 0x00b3ff, side: THREE.DoubleSide } );
    let materialGreen = new THREE.MeshStandardMaterial( { color: 0x00ff00, side: THREE.DoubleSide } );

    let customMaterial = new THREE.ShaderMaterial({
      uniforms: { 
        "s": { type: "f", value: -1.0 },
        "b": { type: "f", value: 1.0 },
        "p": { type: "f", value: 2.0 },
        glowColor: { type: "c", value: new THREE.Color('#00b3ff') }
      },
      vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      transparent: false
    })

    let customMaterialWhite = customMaterial.clone();
    customMaterialWhite.uniforms.glowColor.value.set(new THREE.Color('#ffffff'));

    let fixY = -12.5;
    loadModel(modelurl).then((model) => {
      pivot.add(model);
      model.position.y = fixY; 
      model.traverse((node) => {
        if (node.isMesh) {
          node.material = customMaterial;
        }
      });
    });

    loadModel(modelurl2).then((model) => {
      pivot.add(model);
      model.position.y = fixY; 
      model.traverse((node) => {
        if (node.isMesh){
          node.material = material;
        }
      });
      modelDots = model;
    });

    loadModel(line6).then((model) => {
      model.traverse((node) => {
        if (node.isMesh){
          node.material = material;
        }
      });

      let modelc = model.clone();
      modelc.scale.set(1.85, 1.85, 1.85);

      let linePivot = new THREE.Object3D();
      linePivot.add(modelc);
      linePivot.rotation.z = Math.PI / 4;
      line1 = modelc;
      scene.add(linePivot);

      modelc = model.clone();
      modelc.scale.set(1.85, 1.85, 1.85);
      linePivot = new THREE.Object3D();
      linePivot.add(modelc);
      linePivot.rotation.z = -Math.PI / 4;
      line2 = modelc;
      scene.add(linePivot);

      modelc = model.clone();
      modelc.scale.set(1.25, 1.25, 1.25);
      linePivot = new THREE.Object3D();
      linePivot.add(modelc);
      linePivot.rotation.z = Math.PI / 2;
      line3 = modelc;
      scene.add(linePivot);

      modelc = model.clone();
      modelc.scale.set(1.25, 1.25, 1.25);
      linePivot = new THREE.Object3D();
      linePivot.add(modelc);
      linePivot.position.y = 5;
      line4 = modelc;
      scene.add(linePivot);
    });

    let shield1l = new THREE.Object3D();
    shield1l.position.y = fixY; 
    shield1l.position.x = 16.5; 
    shield1l.position.z = 0.5; 
    shield1l.visible = false;
            
    let shield2l = shield1l.clone();
    let shield3l = shield1l.clone();

    shield1 = shield1l;
    shield2 = shield2l;
    shield3 = shield3l;

    shield2.position.x = -23.5; 
    shield2.position.y = 0; 
    shield3.position.y = 26; 
    shield3.position.x = 0; 

    shield1Pivot.add(shield1);
    shield2Pivot.add(shield2);
    shield3Pivot.add(shield3);

    scene.add(shield1Pivot);
    scene.add(shield2Pivot);
    scene.add(shield3Pivot);

    shield1StartPosition = {
      x: shield1.position.x,
      y: shield1.position.y,
      z: shield1.position.z,
    }

    shield2StartPosition = {
      x: shield2l.position.x,
      y: shield2l.position.y,
      z: shield2l.position.z,
    }

    shield3StartPosition = {
      x: shield3l.position.x,
      y: shield3l.position.y,
      z: shield3l.position.z,
    }

    let shieldPivotRotationZ = 0;

    const animate = () => {
      requestAnimationFrame( animate );
      if(rotationPivot)
        pivot.rotation.y += 0.01;
      shieldPivotRotationZ += 0.01;
      if(shieldPivotRotationZ >= (Math.PI * 2)) {
        shieldPivotRotationZ = 0;
      }
      shieldPivotRotationZ += 0.01;
      if(line1){
        line1.rotation.y += 0.026;
      }
      if(line2){
        line2.rotation.y -= 0.016;
      }
      if(line3){
        line3.rotation.y += 0.026;
      }
      if(line4) {
        line4.rotation.y -= 0.016;
      }
      if(!lockShiled1){
        shield1Pivot.rotation.z = shieldPivotRotationZ;
      }
      if(!lockShiled2){
        shield2Pivot.rotation.z = shieldPivotRotationZ;
      }
      if(!lockShiled3){
        shield3Pivot.rotation.z = shieldPivotRotationZ;
      }
      composer.render();
      TWEEN.update();
    };

    animate();

    let tasks = [];

    const clearTasks = () => {
      TWEEN.removeAll();

      for(let i=-0; i < tasks.length; i++) {
        clearTimeout(tasks[i]);
      }
    }

    const cameraSetup = (point, duration) => {
      new TWEEN.Tween( camera.rotation ).to(point, duration ? duration : 2000 ).start();
    }

    const step1 = () => {
      rotationPivot = true;

      clearTasks();

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: 0, y: 10, z: 30}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)        
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
    }

    const step2 = () => {
      rotationPivot = true;
      modelDots.children[2].material = material;
      
      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1450);

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: -20, y: 0, z: 80}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)
      .onComplete(function(){
      })       
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();

      lockShiled2 = false;
      lockLookShieled = false;
    }

    const step3 = () => {
      rotationPivot = false;

      clearTasks();
      
      lockShiled2 = true;
      lockLookShieled = true;

      shield2.position.copy(shield2StartPosition);

      let cloneCamera = camera.clone();
      // get the current camera position
      const start = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);

      // move camera to the target
      const point = sphere(modelDots.children[2]).center.normalize();
      const camDistance = cloneCamera.position.length() * 0.38;
      cloneCamera.position.copy(point).normalize().multiplyScalar(camDistance);

      // save the camera position
      const end =  new THREE.Vector3(cloneCamera.position.x, cloneCamera.position.y, cloneCamera.position.z);

      new TWEEN.Tween(camera.position)
      .to({z: 80, x: -30, y: 0}, 500)
      .onUpdate(function(){
        camera.lookAt(new THREE.Vector3(shield2StartPosition.x, shield2StartPosition.y, shield2StartPosition.z));
      })
      .onComplete(function() {
        new TWEEN.Tween(camera.position)
        .to({z:2, x: -48, y: 0}, 900)
        .onUpdate(function(){
          shield2.lookAt(camera.position);
          camera.lookAt(new THREE.Vector3(shield2StartPosition.x, shield2StartPosition.y, shield2StartPosition.z));
        })
        .onComplete(function() {
          new TWEEN.Tween(camera.position)
          .to(end, 4000)
          .easing(TWEEN.Easing.Cubic.Out)
          .onUpdate(function () {
            camera.lookAt(point);
          })
          .onComplete(function() {
            modelDots.children[2].material = customMaterialWhite;
          }).start();
        }).start();
      }).start();

      new TWEEN.Tween(shield2Pivot.rotation)
      .onUpdate(function() {
        shield2.lookAt(camera.position);
      })
      .to({z: 0}, 1000)
      .start();
    }

    const step4 = () => {
      rotationPivot = true;
      modelDots.children[1].material = material;
      modelDots.children[2].material = material;

      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1450)

      lockShiled2 = false;
      lockLookShieled = false;

      shield1.position.z = 0
      shield1.position.x = 6; 
      shield1.position.y = 20; 

      shield2Pivot.rotation.z = 0;
      lockShiled2 = false;
      shield2.position.z = 0.5; 
      shield2.position.x = 20; 
      shield2.position.y = 12; 

      lockShiled3 = false;
      shield3.position.z = 0; 
      shield3.position.x = 25.8; 
      shield3.position.y = -3; 

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: 30, y: 10, z: 80}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)        
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
    }

    const step5 = () => {
      rotationPivot = false;
    
      clearTasks();

      let cloneCamera = camera.clone();
      const start = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);

      const point = sphere(modelDots.children[1]).center.normalize();
      const camDistance = cloneCamera.position.length() * 0.28;
      cloneCamera.position.copy(point).normalize().multiplyScalar(camDistance);

      const end = new THREE.Vector3(cloneCamera.position.x, cloneCamera.position.y, cloneCamera.position.z);
    
      shield2.position.x = 24; 
      shield2.position.y =  0; 
      shield2.position.z =  0.7; 
      lockShiled2 = true;
      lockLookShieled = true;

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween( camera.rotation )
      .to({ x: 0, y: -0.2, z: 0}, 500)
      .onComplete(function() {
        new TWEEN.Tween(cameraFrom)
        .to({ z: 2, x: 58, y: 0 }, 2000)
        .delay(500)
       .onUpdate(function(){
          camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
          shield2.lookAt(camera.position)
          camera.lookAt(shield2.position)
        }).onComplete(function() {
          new TWEEN.Tween(camera.position)
          .to(end, 900)
          .onUpdate(function(){
            shield2.lookAt(camera.position)
            //camera.lookAt(shield2.position)
            camera.lookAt(point);
          })
          .onComplete(function() {
            modelDots.children[1].material = customMaterialWhite;
          }).start()
          modelDots.children[1].material = customMaterialWhite;
        }).start();
      }).start();
  
      cameraSetup({x: -0.2347317536273475, y: 0.07404189755525604, z: 0.017688367787720344}, 1000);

      new TWEEN.Tween(shield2Pivot.rotation)
      .onUpdate(function(){
        shield2.lookAt(camera.position);
      })
      .to({z: 0}, 500)
      .start();
    }

    const step6 = () => {
      rotationPivot = true;
      modelDots.children[1].material = material;
      modelDots.children[0].material = material;

      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1450);

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: -20, y: 0, z: 80}, 4000)
      .easing(TWEEN.Easing.Cubic.Out)
      .onComplete(function(){
      })       
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();

      shield2.position.copy(shield2StartPosition);
      lockShiled2 = false;
      lockLookShieled = false;
    }

    const step7 = () => {
      clearTasks();

      rotationPivot = false;
      shield2.position.x = 23.5; 
      shield2.position.y = 0; 
      shield2.position.z = 0.5; 
      lockShiled2 = true;
      lockLookShieled = true;

      let cloneCamera = camera.clone();
      const start = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);

      const point = sphere(modelDots.children[0]).center.normalize();
      const camDistance = cloneCamera.position.length() * 0.38;
      cloneCamera.position.copy(point).normalize().multiplyScalar(camDistance);

      const end = new THREE.Vector3(cloneCamera.position.x, cloneCamera.position.y, cloneCamera.position.z);

      new TWEEN.Tween(camera.position)
      .to({z: 80, x: 28, y: 0 }, 900)
      .onComplete(function() {
        new TWEEN.Tween(camera.position)
        .to({z: 0.5, x: 48, y: 0}, 900)
        .onUpdate(function() {
          shield2.lookAt(camera.position);
          camera.lookAt(shield2.position);
        })
        .onComplete(function() {
          new TWEEN.Tween(camera.position)
          .to(end, 4000)
          .easing(TWEEN.Easing.Cubic.Out)
          .onUpdate(function(){
            shield2.lookAt(camera.position);
            camera.lookAt(shield2.position);
            camera.lookAt(point);
          })
          .onComplete(function() {
            modelDots.children[0].material = customMaterialWhite;
          }).start()
        }).start();
      }).start();

      new TWEEN.Tween(shield2Pivot.rotation)
      .onUpdate(function(){
        shield2.lookAt(camera.position);
      })
      .to({ z: 0 }, 1000)
      .start();
    }

    const step8 = () => {
      rotationPivot = true;
      modelDots.children[0].material = material;

      clearTasks();
      cameraSetup({x: -0.2, y: 0, z: 0}, 1050);

      lockShiled2 = false;
      lockLookShieled = false;

      shield1.position.z = 0
      shield1.position.x = 6; 
      shield1.position.y = 20; 

      shield2Pivot.rotation.z = 0;
      lockShiled2 = false;
      shield2.position.z = 0.5; 
      shield2.position.x = 20; 
      shield2.position.y = 12; 

      lockShiled3 = false;
      shield3.position.z = 1; 
      shield3.position.x = 25.8; 
      shield3.position.y = -3; 

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({ x: 30, y: 10, z: 80}, 4000)
      .easing(TWEEN.Easing.Cubic.Out)        
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
      
      new TWEEN.Tween(shield1Pivot.scale).to({ x: 1, y: 1, z: 1}, 1000).start();
      new TWEEN.Tween(shield2Pivot.scale).to({ x: 1, y: 1, z: 1}, 1000).start();
      new TWEEN.Tween(shield3Pivot.scale).to({ x: 1, y: 1, z: 1}, 1000).start();
    }

    const step9 = () => {
      rotationPivot = true;

      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1050);

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: -10, y: 10, z: 75}, 4000)
      .easing(TWEEN.Easing.Cubic.Out)        
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();

      new TWEEN.Tween(shield1Pivot.scale).to({ x: 10, y: 10, z: 10}, 1000).start();
      new TWEEN.Tween(shield2Pivot.scale).to({ x: 10, y: 10, z: 10}, 1000).start();
      new TWEEN.Tween(shield3Pivot.scale).to({ x: 10, y: 10, z: 10}, 1000).start();
    }

    /*const step1Mobile = () => {
      clearTasks();

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }
      new TWEEN.Tween(cameraFrom)
      .to({x: 0, y: 15, z: 40}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)        
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();


    }

    const step2Mobile = () => {
      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1450)

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: 0, y: 10, z: 30}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)      
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
    }

    const step3Mobile = () => {
      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1450)

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: 0, y: 0, z: 29}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)
      .onComplete(function(){
        shield2.rotation.y = 0;
      })       
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
    }

    const step4Mobile = () => {
      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1450)

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: 0, y: 0, z: 39}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)
      .onComplete(function(){
        shield1.rotation.y = 0;
        shield3.rotation.y = 0;
      })       
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
    }

    const step5Mobile = () => {
      clearTasks();
      cameraSetup({x: 0, y: 0, z: 0}, 1450)

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({x: 0, y: 0, z: 47}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)
      .onComplete(function(){
        shield2.rotation.y = 0;
      })       
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
    }

    const step6Mobile = ()=>{
      clearTasks();

      let cameraFrom = {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z
      }

      new TWEEN.Tween(cameraFrom)
      .to({ x: 0, y: 20, z: 40}, 2000)
      .easing(TWEEN.Easing.Cubic.Out)        
      .onUpdate(function () {
        camera.position.set(cameraFrom.x, cameraFrom.y, cameraFrom.z);
      }).start();
    }*/

    function sphere(object) {
      let sphere;
      object.updateMatrixWorld();
      object.geometry.computeBoundingSphere();
      sphere = object.geometry.boundingSphere.clone();
      sphere.applyMatrix4(object.matrixWorld);
      return sphere;
    }

    function onscroll() {
      let scrollTop = document.body.scrollTop;

      if(step != 1 && scrollTop > 0 && scrollTop < 1000) {
        step = 1;
        step1();
      } else if(step != 2 && scrollTop > 1000 && scrollTop < 2000) {
        step = 2;
        step2();
      } else if(step != 3 && scrollTop > 2000 && scrollTop < 3000) {
        step = 3;
        step3();
      } else if(step != 4 && scrollTop > 3000 && scrollTop < 4000) {
        step = 4;
        step4();
      } else if(step != 5 && scrollTop > 4000 && scrollTop < 5000) {
        step = 5;
        step5();
      } else if(step != 6 && scrollTop > 5000 && scrollTop < 6000) {
        step = 6;
        step6();
      } else if(step != 7 && scrollTop > 6000 && scrollTop < 7000) {
        step = 7;
        step7();
      } else if(step != 8 && scrollTop > 7000 && scrollTop < 8000) {
        step = 8;
        step8();
      } else if(step != 9 && scrollTop > 8000 && scrollTop < 9000) {
        step = 9;
        step9();
      }
    }

    function onscrollMobile() {
      let scrollTop = document.body.scrollTop;
      if(step == 1) {
          step1();
      } if(step == 2) {
          step2();
      } if(step == 3) {
          step3();
      } if(step == 4) {
          step4();
      } if(step == 5) {
          step5();
      } if(step == 6) {
          step6();
      } if(step == 7) {
          step7();
      } if(step == 8) {
          step8();
      } if(step == 9) {
          step9();
      }
    }

    const raycaster = new THREE.Raycaster();

    if(isMobile) {
      window.onscroll = function() {
        onscrollMobile()
      };
      document.addEventListener('touchstart', handleTouchStart, false);
      document.addEventListener('touchmove', handleTouchMove, false);

      var xDown = null;                                                        
      var yDown = null;

      function getTouches(evt) {
        return evt.touches || evt.originalEvent.touches; 
      }                                                     
                                                                              
      function handleTouchStart(evt) {
        const firstTouch = getTouches(evt)[0];                                      
        xDown = firstTouch.clientX;                                      
        yDown = firstTouch.clientY;       
        const mouse = {
          x: (xDown / renderer.domElement.clientWidth) * 2 - 1,
          y: -(yDown / renderer.domElement.clientHeight) * 2 + 1,
        }
        raycaster.setFromCamera(mouse, camera)
        const intersects = raycaster.intersectObjects(sceneMeshes, false)
        if (intersects.length > 0) {
          if(step === 3){
           // new TWEEN.Tween(shield1.rotation ).to({ x: 0, y: shield1.rotation.y === 0 ? Math.PI : 0, z: 0}, 1000).start();
          }
          if(step === 4){
           // new TWEEN.Tween(shield2.rotation ).to({ x: 0,y: shield2.rotation.y === 0 ? Math.PI : 0, z: 0}, 1000).start();
          }
          if(step === 5){
            //new TWEEN.Tween(shield3.rotation ).to({ x: 0, y: shield3.rotation.y === 0 ? Math.PI : 0, z: 0}, 1000).start();
          }
        }                               
      };                                               
                                                                              
      function handleTouchMove(evt) {
        if ( ! xDown || ! yDown ) {
          return;
        }

        let xUp = evt.touches[0].clientX;                                    
        let yUp = evt.touches[0].clientY;

        let xDiff = xDown - xUp;
        let yDiff = yDown - yUp;
                                                                              
        if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {
          if ( xDiff > 0 ) {
          } else {
          }                       
        } else {
          if ( yDiff > 0 ) {
            if(step < 9){
              step++;
            }
            onscrollMobile();
          } else {
            if(step > 1){
              step--;
            }
            onscrollMobile();
          }                                                                 
        }
        xDown = null;
        yDown = null;                                             
      };
    } else {
      window.onscroll = function() {
        onscroll()
      };
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
    }

    window.addEventListener('resize', onWindowResize);
  </script>
</body>

